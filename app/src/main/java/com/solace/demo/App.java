/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.solace.demo;

import com.solace.demo.geofiltering.Constants;
import com.solace.demo.geofiltering.FilteringRequest;
import com.solace.demo.geofiltering.RangesFinder;
import com.solacesystems.jcsmp.BytesXMLMessage;
import com.solacesystems.jcsmp.JCSMPException;
import com.solacesystems.jcsmp.JCSMPFactory;
import com.solacesystems.jcsmp.JCSMPProperties;
import com.solacesystems.jcsmp.JCSMPSession;
import com.solacesystems.jcsmp.JCSMPStreamingPublishCorrelatingEventHandler;
import com.solacesystems.jcsmp.TextMessage;
import com.solacesystems.jcsmp.Topic;
import com.solacesystems.jcsmp.XMLMessageConsumer;
import com.solacesystems.jcsmp.XMLMessageProducer;
import java.util.concurrent.Callable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import picocli.CommandLine;
import picocli.CommandLine.Option;

@CommandLine.Command(showDefaultValues = true)
public class App implements Callable<Integer> {
    final Logger logger = LoggerFactory.getLogger(App.class);
    @Option(names = {"-h", "--help"}, usageHelp = true, description = "display this help message")
    private boolean usageHelpRequested;

    @Option(names = {"-H", "--host"}, defaultValue = "${env:solace_host:-localhost:44444}",
            description = "ip[:port]  IP and port of the event broker. (e.g. -h=192.168.160.101), if not specified, read from the env variable solace_host")
    private String host;

    @Option(names = {"-u", "--username"}, defaultValue = "${env:solace_username:-default@default}",
            description = "user[@vpn] Client username and optionally VPN name, , if not specified, read from the env variable solace_username")
    private String userName;

    @Option(names = {"-p", "--password"}, defaultValue = "${env:solace_password:-default}",
            description = "Client password, if not specified, read from the env variable solace_password")
    private String password;

    private JCSMPSession session;
    private XMLMessageConsumer consumer;
    private XMLMessageProducer producer;

    // switch off the jcsmp output
    // (https://stackoverflow.com/questions/35313868/solace-how-to-switch-off-the-info-statements-sent-to-std-err-from-solace-java-a)
    static {
        System.setProperty("org.apache.commons.logging.Log",
                "org.apache.commons.logging.impl.NoOpLog");
    }

    public static void main(String[] args) {
        int exitCode = new CommandLine(new App()).execute(args);
        System.exit(exitCode);
    }

    @Override
    public Integer call() throws Exception {
        Integer r = connectToBroker();
        if (r != 0) {
            return r;
        }
        CtrlCHelper.waitForCtrlC("Press Ctrl+C to exit");
        // Close consumer
        // consumer.close();
        System.out.println("Exiting.");
        session.closeSession();

        return null;
    }

    private Integer connectToBroker() throws Exception {
        final var names = userName.split("@");
        var vpnName = names.length > 1 ? names[1] : "default";

        final JCSMPProperties properties = new JCSMPProperties();
        properties.setProperty(JCSMPProperties.HOST, host);
        properties.setProperty(JCSMPProperties.USERNAME, names[0]);
        properties.setProperty(JCSMPProperties.VPN_NAME, vpnName);
        properties.setProperty(JCSMPProperties.PASSWORD, password);
        properties.setProperty(JCSMPProperties.CLIENT_NAME, "geo-filtering");
        session = JCSMPFactory.onlyInstance().createSession(properties);

        logger.info("Start to connect to host {}, with user {}@{}", host, names[0], vpnName);
        session.connect();

        // Simple anonymous inner-class for handling publishing events
        producer = session.getMessageProducer(new JCSMPStreamingPublishCorrelatingEventHandler() {
            // unused in Direct Messaging application, only for Guaranteed/Persistent
            // publishing application
            @Override
            public void responseReceivedEx(Object key) {
            }

            // can be called for ACL violations, connection loss, and Persistent NACKs
            @Override
            public void handleErrorEx(Object key, JCSMPException cause, long timestamp) {
                logger.error("Producer handleErrorEx() callback: {}", cause.toString());
            }
        });
        consumer = session.getMessageConsumer(new MessageListener(this));
        final Topic topic = JCSMPFactory.onlyInstance().createTopic("geo/filtering");
        session.addSubscription(topic);
        consumer.start();
        logger.info("Connected. Awaiting message...");
        return 0;
    }

    void onMessageReceived(BytesXMLMessage requestMsg) {
        if (requestMsg.hasAttachment()) {
            try {
                var request = FilteringRequest.from(requestMsg.getAttachmentByteBuffer().array());
                logger.info("=== Received a filtering request");
                var result = RangesFinder.find(request);

                TextMessage replyMsg = JCSMPFactory.onlyInstance().createMessage(TextMessage.class);
                replyMsg.setText(result.toJsonString());
                logger.info("Send back the reply message ({} bytes)", replyMsg.getText().length());
                producer.sendReply(requestMsg, replyMsg);

                var clientName = JCSMPFactory.onlyInstance().createClientName(request.getClientName());
                try {
                    if (request.getPrevResult() != null) {
                        // remove previous subscriptions first
                        logger.info("To remove previous {} subscriptions first",
                                request.getPrevResult().getRanges().size());
                        var topicPattern = request.getPrevResult().getTopicPattern();
                        for (var range : request.getPrevResult().getRanges()) {
                            var temp = topicPattern.replace("{lat}", range.getFiltering().get(Constants.DIMS.Y));
                            var topic = temp.replace("{lng}", range.getFiltering().get(Constants.DIMS.X));
                            session.removeSubscription(clientName, JCSMPFactory.onlyInstance().createTopic(topic),
                                    JCSMPSession.WAIT_FOR_CONFIRM);
                        }
                    }

                    var topicPattern = result.getTopicPattern();
                    logger.info("To subscribe on {} ranges", result.getRanges().size());
                    for (var range : result.getRanges()) {
                        var temp = topicPattern.replace("{lat}", range.getFiltering().get(Constants.DIMS.Y));
                        var topic = temp.replace("{lng}", range.getFiltering().get(Constants.DIMS.X));
                        session.addSubscription(clientName, JCSMPFactory.onlyInstance().createTopic(topic),
                                JCSMPSession.WAIT_FOR_CONFIRM);
                    }
                } catch (JCSMPException e) {
                    logger.error("Error: {}}", e.toString());
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            logger.info("Received Message: type->{}, AttachmentContentLength->{}, ContentLength()->{}",
                    requestMsg.getClass().getCanonicalName(),
                    requestMsg.getAttachmentContentLength(),
                    requestMsg.getContentLength());
        }
    }
}
