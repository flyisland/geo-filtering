/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.solace.demo;

import com.solace.demo.geofiltering.FilteringRequest;
import com.solace.demo.geofiltering.RangesFinder;
import com.solacesystems.jcsmp.BytesXMLMessage;
import com.solacesystems.jcsmp.JCSMPException;
import com.solacesystems.jcsmp.JCSMPFactory;
import com.solacesystems.jcsmp.JCSMPProperties;
import com.solacesystems.jcsmp.JCSMPSession;
import com.solacesystems.jcsmp.JCSMPStreamingPublishCorrelatingEventHandler;
import com.solacesystems.jcsmp.TextMessage;
import com.solacesystems.jcsmp.Topic;
import com.solacesystems.jcsmp.XMLMessageConsumer;
import com.solacesystems.jcsmp.XMLMessageProducer;
import java.util.concurrent.Callable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import picocli.CommandLine;
import picocli.CommandLine.Option;



public class App implements Callable<Integer>
{
    final Logger logger = LoggerFactory.getLogger(App.class);

    @Option(names = {"-h",
            "--host"}, description = "ip[:port]  IP and port of the event broker. (e.g. -h=192.168.160.101)")
    private String host = "localhost:44444";

    @Option(names = {"-u", "--username"}, description = "user[@vpn]  Client username and optionally VPN name.")
    private String userName = "default@default";

    @Option(names = {"-p", "--password"}, description = "Client password")
    private String password = "default";

    private JCSMPSession session;
    private XMLMessageConsumer consumer;
    private XMLMessageProducer producer;
    // switch off the jcsmp output
    // (https://stackoverflow.com/questions/35313868/solace-how-to-switch-off-the-info-statements-sent-to-std-err-from-solace-java-a)
    static {
        System.setProperty("org.apache.commons.logging.Log",
                "org.apache.commons.logging.impl.NoOpLog");
    }

    public static void main(String[] args) {
        int exitCode = new CommandLine(new App()).execute(args);
        System.exit(exitCode);
    }

    @Override
    public Integer call() throws Exception {
        connectToBroker();
        CtrlCHelper.waitForCtrlC("Press Ctrl+C to exit");
        // Close consumer
        // consumer.close();
        System.out.println("Exiting.");
        session.closeSession();

        return null;
    }

    private void connectToBroker() throws Exception {
        final var names = userName.split("@");
        var vpnName = names.length > 1 ? names[1] : "default";

        final JCSMPProperties properties = new JCSMPProperties();
        properties.setProperty(JCSMPProperties.HOST, host);
        properties.setProperty(JCSMPProperties.USERNAME, userName);
        properties.setProperty(JCSMPProperties.VPN_NAME, vpnName);
        properties.setProperty(JCSMPProperties.PASSWORD, password);
        properties.setProperty(JCSMPProperties.CLIENT_NAME, "geo-filtering");
        session = JCSMPFactory.onlyInstance().createSession(properties);

        logger.info("Start to connect to host {}, with user {}", host, userName);
        session.connect();
        // Simple anonymous inner-class for handling publishing events
        producer = session.getMessageProducer(new JCSMPStreamingPublishCorrelatingEventHandler() {
            // unused in Direct Messaging application, only for Guaranteed/Persistent publishing application
            @Override
            public void responseReceivedEx(Object key) {
            }

            // can be called for ACL violations, connection loss, and Persistent NACKs
            @Override
            public void handleErrorEx(Object key, JCSMPException cause, long timestamp) {
                logger.error("Producer handleErrorEx() callback: {}", cause.toString());
            }
        });
        consumer = session.getMessageConsumer(new MessageListener(this));
        final Topic topic = JCSMPFactory.onlyInstance().createTopic("geo/filtering");
        session.addSubscription(topic);
        consumer.start();
        logger.info("Connected. Awaiting message...");
    }

    void onMessageReceived(BytesXMLMessage requestMsg) {
        if (requestMsg.hasAttachment()) {
            try {
                var request = FilteringRequest.from(requestMsg.getAttachmentByteBuffer().array());
                var result = RangesFinder.find(request);
                TextMessage replyMsg = JCSMPFactory.onlyInstance().createMessage(TextMessage.class);
                replyMsg.setText(result.toJsonString());
                try {
                    producer.sendReply(requestMsg, replyMsg);
                } catch (JCSMPException e) {
                    logger.error("Error sending reply.");
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            logger.info("Received Message: type->{}, AttachmentContentLength->{}, ContentLength()->{}",
                    requestMsg.getClass().getCanonicalName(),
                    requestMsg.getAttachmentContentLength(),
                    requestMsg.getContentLength());
        }
    }
}
